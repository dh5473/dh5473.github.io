{"componentChunkName":"component---src-templates-post-template-tsx","path":"/redis-pub-sub/","result":{"data":{"site":{"siteMetadata":{"title":"Donhyeok's Blog","description":"Donhyeok's Blog","siteUrl":"https://dh5473.github.io"}},"allMarkdownRemark":{"edges":[{"node":{"html":"<p>서비스를 개발 하다 보면 <strong>“하나의 이벤트가 발생했을 때 여러 시스템이 동시에 반응해야 하는”</strong> 상황을 자주 마주하게 됩니다. 예를 들어, 고객이 온라인 쇼핑몰에서 주문을 완료하면 다음과 같은 작업들이 동시에 일어나야 합니다.</p>\n<ul>\n<li>결제 시스템에서 결제 처리</li>\n<li>재고 시스템에서 상품 수량 차감</li>\n<li>배송 시스템에서 배송 준비 시작</li>\n<li>주문 확인 이메일/SMS 발송</li>\n<li>고객 포인트 적립 처리</li>\n<li>주문 통계 데이터 업데이트</li>\n</ul>\n<p>가장 직관적인 방법은 주문 처리 코드에서 각각의 시스템을 순차적으로 호출하는 것입니다. 하지만 특정 단계에서 문제가 생기면 전체 주문 과정이 멈춰버리고, 새로운 기능을 추가할 때마다 기존 주문 코드를 수정해야 하는 번거로움도 있습니다.</p>\n<p><strong>“이벤트를 발생시키기만 하면, 관심 있는 시스템들이 알아서 처리하게 할 수는 없을까?”</strong></p>\n<p>바로 이런 고민에서 나온 해결책이 <strong>Publish-Subscribe 패턴</strong>입니다. 이벤트를 ‘발행(Publish)‘하면, 해당 이벤트에 관심 있는 시스템들이 ‘구독(Subscribe)‘해서 각자 필요한 작업을 처리하는 방식입니다.</p>\n<h1>Publish-Subscribe</h1>\n<p>분산 시스템이나 마이크로서비스 아키텍처에서는 서로 다른 컴포넌트 간의 메시지 교환 방식을 메시징 패턴으로 정의합니다. 메시징 패턴에는 Request-Reply, Publish-Subscribe, Push-Pull 등 다양한 패턴이 있는데, 그중에서도 Publish-Subscribe 패턴에 대해 자세히 알아보겠습니다.</p>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpElEQVR42p1SWVODMBDm/z/6rOOD44y/QPvg8eJ9taL2QpteYClFFIEkQPhc0k6tU52xLpOQbHa/Pb418IMUBVaSMBHw3iJ9Nspt9OaTMvozQJalEIIjlVLf96sdbB2YkJmCkUiBjdNdHDWr+lGQURAEUEotZKxma5p6u+vCvLFhPln0qNBgDs5MiwJlMMrtvGGi1Wfa2As+cGy9IoriGVix1Ao2HMNqeni2baSphEhiJFE4BVS5oksMnnBtnAgBxw8hdTkFZVrAHzbhsipyKlUSQNsa4fGBwR6/aJ/hJERr6H/1cJ4BfSVwFIYElOuyCQ8ne9uo7KxB8gQiFbirj3D/4KE7trVf5crCZuUaMi+mgHYwwTuRUgIcszrOL9vgMZ8HirnAexjNW+C6Hnq9Pv1drRs4LtpsQFWJKSnrJzNSKJ17h6EzGCEV6a/j1GAezCsft0RKoTJEFDD4iDVxmpQLIsUa9JZI+NaMBb3nB3hxfIz9V30/rHWwvV9FmqMkJSeWOATnM9fVB7vW6uLwuq5HzsA/pAyoF53LvpfJcBqdPMvwCTdlTuowBK2XAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/e4aa89bbe4d6a586a05d515bf693e49e/a59e9/pub-sub-pattern.webp 192w,\n/static/e4aa89bbe4d6a586a05d515bf693e49e/0ca9f/pub-sub-pattern.webp 384w,\n/static/e4aa89bbe4d6a586a05d515bf693e49e/a23a1/pub-sub-pattern.webp 694w\"\n              sizes=\"(max-width: 694px) 100vw, 694px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/e4aa89bbe4d6a586a05d515bf693e49e/3b721/pub-sub-pattern.png 192w,\n/static/e4aa89bbe4d6a586a05d515bf693e49e/66595/pub-sub-pattern.png 384w,\n/static/e4aa89bbe4d6a586a05d515bf693e49e/91652/pub-sub-pattern.png 694w\"\n            sizes=\"(max-width: 694px) 100vw, 694px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/e4aa89bbe4d6a586a05d515bf693e49e/91652/pub-sub-pattern.png\"\n            alt=\"Pub-Sub 패턴 개념도\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n    </span></p>\n<p align=\"center\" style=\"color: #666; font-size: 14px;\"><em>Publish-Subscribe 패턴 (출처: <a href=\"https://aws.amazon.com/what-is/pub-sub-messaging/\" target=\"_blank\">AWS</a>)</em></p>\n<ul>\n<li><strong>Publisher</strong>: 메시지를 생성해 특정 토픽에 발행</li>\n<li><strong>Broker</strong>: 발행된 메시지를 받아 구독자들에게 전달하는 중개자</li>\n<li><strong>Subscriber</strong>: 관심 있는 토픽을 구독하고 메시지를 수신</li>\n</ul>\n<p>Publish-Subscribe는 특정한 주제(Topic)에 대하여 해당 토픽을 구독한 모든 구독자에게 메시지를 발행하는 방식입니다. 발행자와 구독자는 서로를 모르는 상태에서 통신하기 때문에 서비스 간 의존도를 낮출 수 있고, 토픽을 늘리는 방식으로 수평 확장이 가능하다는 장점이 있습니다.</p>\n<br>\n<p>이러한 특성 덕분에 다음과 같은 상황에서 유용하게 활용됩니다.</p>\n<ul>\n<li>여러 서비스가 <strong>하나의 이벤트를 동시에 반응</strong>해야 할 때</li>\n<li><strong>실시간 브로드캐스트</strong>가 필요한 채팅, 알림, 모니터링 시스템</li>\n<li>이벤트 기반 마이크로서비스 구조에서 <strong>서비스 간 직접 호출 없이</strong> 데이터를 전파하고자 할 때</li>\n</ul>\n<p>물론 장점만 있는 것은 아닙니다. 메시지를 활용해 통신을 주고 받는 만큼, 메시지를 실제로 수신했는지, 중복해서 수신하지는 않았는지 등에 대한 상태 관리가 필요합니다. 따라서 신뢰성 혹은 순서 보장 등 추가적인 요구 사항이 필요한 경우에는 Apache Kafka와 같은 더 정교한 메시징 시스템을 활용하여야 합니다.</p>\n<h1>Redis Pub / Sub</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.29166666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEElEQVR42nWRSU/DMBCF8/+5cOTEP4FeWG5UoKKWorYO0ChkcdYmju344ZmUHlgsPVueGX96Mw7GcYS1Ft+ncw6/ls/55I/QCK01qqqClBJlWUIphYC2PM8RhiHqukbTNND0uJRw2xdg/wZxfob95QUQv8NtVnBFDqUNhmFgUBzHSNOU74ExhskkChijob1Js3rC4W4Gudvg8/EBcrlA8xGiu5/B+tzgyLRhA23bsk7Arus40Pc9A6lYLeaob66QrpdIPYxUiS0Ot9dQz3N0xkIfHUZRhCRJJiBByK4QgpPtsWVX5nC7NZx49eck60fAMW5ZM6AoCn6fZdk0QxouiT7j30/5Y1EddUdzJxiByeEXXn3K/lXjY+EAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/505764707cd9a90d6d055f8823108ddf/a59e9/redis-pub-sub.webp 192w,\n/static/505764707cd9a90d6d055f8823108ddf/0ca9f/redis-pub-sub.webp 384w,\n/static/505764707cd9a90d6d055f8823108ddf/dc9b9/redis-pub-sub.webp 768w,\n/static/505764707cd9a90d6d055f8823108ddf/e2c2f/redis-pub-sub.webp 1152w,\n/static/505764707cd9a90d6d055f8823108ddf/53f84/redis-pub-sub.webp 1240w\"\n              sizes=\"(max-width: 768px) 100vw, 768px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/505764707cd9a90d6d055f8823108ddf/3b721/redis-pub-sub.png 192w,\n/static/505764707cd9a90d6d055f8823108ddf/66595/redis-pub-sub.png 384w,\n/static/505764707cd9a90d6d055f8823108ddf/fe486/redis-pub-sub.png 768w,\n/static/505764707cd9a90d6d055f8823108ddf/d2d74/redis-pub-sub.png 1152w,\n/static/505764707cd9a90d6d055f8823108ddf/09504/redis-pub-sub.png 1240w\"\n            sizes=\"(max-width: 768px) 100vw, 768px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/505764707cd9a90d6d055f8823108ddf/fe486/redis-pub-sub.png\"\n            alt=\"Redis Pub/Sub 구조도\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n    </span></p>\n<p align=\"center\" style=\"color: #666; font-size: 14px;\"><em>Redis Pub/Sub 구조 (출처: <a href=\"https://pompitzz.github.io/blog/Redis/LocalCacheSyncWithRedisPubSub.html\" target=\"_blank\">pompitzz 블로그</a>)</em></p>\n<br>\nRedis Pub/Sub은 Redis가 제공하는 메시징 기능으로 매우 단순한 구조로 되어 있습니다. 메시지를 publish하면 해당 채널을 구독하고 있는 모든 subscriber에게 메시지를 전달합니다. Redis Pub/Sub은 단순하고 구현이 쉬운 만큼 다음과 같은 특징을 주의해야 합니다.\n<ul>\n<li><strong>메시지 유실 가능성</strong>: Subscriber가 존재하지 않으면, 메시지는 사라집니다.</li>\n<li><strong>전송 보장 없음</strong>: 네트워크 장애 시 메시지가 전달되지 않을 수 있습니다.</li>\n<li><strong>메시지 순서</strong>: 여러 Publisher가 동시에 메시지를 보낼 때 순서가 보장되지 않을 수 있습니다.</li>\n<li><strong>재시도 메커니즘 부재</strong>: 실패한 메시지에 대한 재처리 기능이 없습니다.</li>\n</ul>\n<p>결국 보내는 쪽도 보내고 끝, 받는 쪽도 받고 끝인 단순한 구조 때문에 일반적인 메시지 큐로 취급되지 않습니다. 이렇듯 단점이 명확하지만, Redis는 In-Memory 기반인 만큼 매우 빠르게 메시지를 주고받을 수 있기 때문에, 짧고 간단한 메시지를 빠르게 보내고 싶을 때는 유용하게 사용할 수 있습니다.</p>\n<h1>코드 예시</h1>\n<p>Redis Pub/Sub을 실제로 사용하려면 Redis 서버를 실행해야 합니다.</p>\n<h3>Publisher (발행자)</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> redis\n\nclient <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>host<span class=\"token operator\">=</span><span class=\"token string\">\"localhost\"</span><span class=\"token punctuation\">,</span> port<span class=\"token operator\">=</span><span class=\"token number\">6379</span><span class=\"token punctuation\">)</span>\nchannel_name <span class=\"token operator\">=</span> <span class=\"token string\">\"news\"</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    message <span class=\"token operator\">=</span> <span class=\"token string-interpolation\"><span class=\"token string\">f\"안녕하세요, Redis Pub/Sub 테스트입니다! (</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">)\"</span></span>\n    client<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span>channel_name<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"[PUBLISH] (</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>channel_name<span class=\"token punctuation\">}</span></span><span class=\"token string\">) -> </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"발행 완료. Publisher 종료.\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">redis.Redis()</code>: Redis 서버에 연결합니다. 기본적으로 localhost:6379에 연결됩니다.</li>\n<li><code class=\"language-text\">client.publish()</code>: 지정된 채널에 메시지를 발행합니다. 메시지를 받은 구독자 수를 반환합니다.</li>\n</ul>\n<h3>Subscriber (구독자)</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> redis\n\nclient <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>host<span class=\"token operator\">=</span><span class=\"token string\">\"localhost\"</span><span class=\"token punctuation\">,</span> port<span class=\"token operator\">=</span><span class=\"token number\">6379</span><span class=\"token punctuation\">)</span>\nchannel_name <span class=\"token operator\">=</span> <span class=\"token string\">\"news\"</span>\n\npubsub <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span>pubsub<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\npubsub<span class=\"token punctuation\">.</span>subscribe<span class=\"token punctuation\">(</span>channel_name<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 채널 구독</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"[SUBSCRIBE] '</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>channel_name<span class=\"token punctuation\">}</span></span><span class=\"token string\">' 채널을 구독하였습니다. 메시지를 기다립니다...\"</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 구독 상태로 대기하면서 메시지를 읽어들임</span>\n<span class=\"token keyword\">for</span> message <span class=\"token keyword\">in</span> pubsub<span class=\"token punctuation\">.</span>listen<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> message<span class=\"token punctuation\">[</span><span class=\"token string\">\"type\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"message\"</span><span class=\"token punctuation\">:</span>\n        data <span class=\"token operator\">=</span> message<span class=\"token punctuation\">[</span><span class=\"token string\">\"data\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"[RECEIVE] (</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>channel_name<span class=\"token punctuation\">}</span></span><span class=\"token string\">) &lt;- </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">client.pubsub()</code>: Redis Pub/Sub 객체를 생성합니다. 이 객체를 통해 구독과 수신을 처리합니다.</li>\n<li><code class=\"language-text\">pubsub.subscribe()</code>: 특정 채널을 구독합니다. 여러 채널을 동시에 구독할 수도 있습니다.</li>\n<li><code class=\"language-text\">pubsub.listen()</code>: 블로킹 방식으로 메시지를 대기합니다. 메시지가 오면 즉시 반환됩니다.</li>\n<li><code class=\"language-text\">message[\"type\"]</code>: Redis는 구독 확인, 메시지 수신 등 다양한 타입의 메시지를 보내므로 “message” 타입만 처리합니다.</li>\n</ul>\n<br>\n<p><strong>💡 주요 포인트</strong></p>\n<ul>\n<li>구독자가 먼저 실행되어야 메시지를 받을 수 있습니다. 구독자가 없으면 메시지는 사라집니다.</li>\n<li><code class=\"language-text\">listen()</code>은 무한 루프로 동작하므로 Ctrl+C로 종료할 수 있습니다.</li>\n<li>하나의 채널에 여러 구독자가 있으면 모든 구독자가 동일한 메시지를 받습니다.</li>\n</ul>\n<h2>실행 결과</h2>\n<p>터미널을 2개 열고, 먼저 Subscriber(구독자)를 실행합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>SUBSCRIBE<span class=\"token punctuation\">]</span> <span class=\"token string\">'news'</span> 채널을 구독하였습니다. 메시지를 기다립니다<span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>다른 터미널에서는 Publisher(발행자)를 실행합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>PUBLISH<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>news<span class=\"token punctuation\">)</span> -<span class=\"token operator\">></span> 안녕하세요, Redis Pub/Sub 테스트입니다<span class=\"token operator\">!</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span>PUBLISH<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>news<span class=\"token punctuation\">)</span> -<span class=\"token operator\">></span> 안녕하세요, Redis Pub/Sub 테스트입니다<span class=\"token operator\">!</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">..</span>.\n<span class=\"token punctuation\">[</span>PUBLISH<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>news<span class=\"token punctuation\">)</span> -<span class=\"token operator\">></span> 안녕하세요, Redis Pub/Sub 테스트입니다<span class=\"token operator\">!</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n발행 완료. Publisher 종료.</code></pre></div>\n<p>Subscriber 터미널에서 발행된 메시지가 순서대로 출력되는 것을 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>RECEIVE<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>news<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span>- 안녕하세요, Redis Pub/Sub 테스트입니다<span class=\"token operator\">!</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span>RECEIVE<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>news<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span>- 안녕하세요, Redis Pub/Sub 테스트입니다<span class=\"token operator\">!</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">..</span>.\n<span class=\"token punctuation\">[</span>RECEIVE<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>news<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span>- 안녕하세요, Redis Pub/Sub 테스트입니다<span class=\"token operator\">!</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>이처럼 Redis Pub/Sub은 매우 간단한 구조로 동작합니다. 발행자는 메시지를 보내고, 구독자는 실시간으로 메시지를 받아볼 수 있습니다.</p>\n<h3>패턴 매칭을 활용한 구독</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> redis\n\nclient <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>host<span class=\"token operator\">=</span><span class=\"token string\">\"localhost\"</span><span class=\"token punctuation\">,</span> port<span class=\"token operator\">=</span><span class=\"token number\">6379</span><span class=\"token punctuation\">,</span> db<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\npubsub <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span>pubsub<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 'news:'로 시작하는 모든 채널 구독</span>\npattern <span class=\"token operator\">=</span> <span class=\"token string\">\"news:*\"</span>\npubsub<span class=\"token punctuation\">.</span>psubscribe<span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"[PSUBSCRIBE] 패턴 '</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>pattern<span class=\"token punctuation\">}</span></span><span class=\"token string\">' 로 구독을 시작합니다. 메시지를 기다립니다...\"</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">for</span> message <span class=\"token keyword\">in</span> pubsub<span class=\"token punctuation\">.</span>listen<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> message<span class=\"token punctuation\">[</span><span class=\"token string\">\"type\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"pmessage\"</span><span class=\"token punctuation\">:</span>\n        channel <span class=\"token operator\">=</span> message<span class=\"token punctuation\">[</span><span class=\"token string\">\"channel\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span>\n        data <span class=\"token operator\">=</span> message<span class=\"token punctuation\">[</span><span class=\"token string\">\"data\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"[RECEIVE] (</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>channel<span class=\"token punctuation\">}</span></span><span class=\"token string\">) &lt;- </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>코드 설명:</strong></p>\n<ul>\n<li><code class=\"language-text\">pubsub.psubscribe()</code>: 패턴 기반 구독을 시작합니다. 와일드카드(<code class=\"language-text\">*</code>)를 사용해 여러 채널을 한 번에 구독할 수 있습니다.</li>\n<li><code class=\"language-text\">\"news:*\"</code>: <code class=\"language-text\">news:</code>로 시작하는 모든 채널을 의미합니다. 예를 들어 <code class=\"language-text\">news:korea</code>, <code class=\"language-text\">news:world</code>, <code class=\"language-text\">news:tech</code> 등이 모두 매칭됩니다.</li>\n<li><code class=\"language-text\">message[\"type\"] == \"pmessage\"</code>: 패턴 구독에서는 메시지 타입이 “pmessage”입니다.</li>\n<li><code class=\"language-text\">message[\"channel\"]</code>: 실제 메시지가 발행된 채널명을 알 수 있습니다.</li>\n</ul>\n<h1>마무리</h1>\n<p>Redis Pub/Sub은 <strong>빠르고 간단한 실시간 메시징</strong>이 필요할 때 매우 유용한 도구입니다. 복잡한 설정 없이도 몇 줄의 코드만으로 이벤트 기반 아키텍처를 구축할 수 있어서, 실시간 알림이나 채팅 시스템, 간단한 마이크로서비스 간 통신에 적합합니다.</p>\n<p>다만 메시지 유실 가능성과 순서 보장의 한계가 있으므로, 중요한 비즈니스 로직에는 신중하게 사용해야 합니다. 만약 메시지 지속성과 순서 보장이 중요하다면 <strong>Redis Streams</strong>를, 대용량 메시지 처리와 복잡한 라우팅이 필요하다면 <strong>Apache Kafka</strong>를 고려해볼 수 있습니다.</p>\n<h2>참고 자료</h2>\n<ul>\n<li><a href=\"https://redis.io/docs/manual/pubsub/\" target=\"_blank\" rel=\"nofollow\">Redis 공식 문서 - Pub/Sub</a></li>\n<li><a href=\"https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-PUBSUB-%EA%B8%B0%EB%8A%A5-%EC%86%8C%EA%B0%9C-%EC%B1%84%ED%8C%85-%EA%B5%AC%EB%8F%85-%EC%95%8C%EB%A6%BC\" target=\"_blank\" rel=\"nofollow\">REDIS의 PUB/SUB 기능</a></li>\n</ul>","frontmatter":{"title":"Redis Pub/Sub 활용하기","summary":"Pub-Sub 패턴에 대해 알아보고, Redis Pub/Sub으로 간단한 실습을 진행합니다.","date":"2025.06.06.","category":"Dev","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABD0lEQVR42mP4RwFgwBR6/vx5UlLSiRMnTp8+XVhYuGLFii1btvz9+5cozY8ePfL396+srKytrQUypkyZEh0d/ePHD6I0w8FfMCDN2UDwBWj7vDlXCnMuZ6bc6uv6cu8OsZpfXji/3cL44bQpt+qrj7k7LdZQX6Ot/vXNW+yaP3z4AAyYS5cunTx5sr+///nF8ys11Zdpqq0z1l+pqwlkAMlvb9+1t7cD1Vy9erWtre3nz59QzS9fvszMzGxoaMjJybG0tLy8aydQA0iPlupyLfUlWmrLdTS+vnsHDLyCgoLy8nJzc/Nbt25hd/aPb1/PL1y41tMNqB+oeUtSwt0D+0gIMEhQPzp+/PXNG3hCGwAyv/eCnju7VwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/8131e3611fd2b1ab87ec7b1afec2f09c/40e69/redis-pub-sub-background.webp","srcSet":"/static/8131e3611fd2b1ab87ec7b1afec2f09c/b150d/redis-pub-sub-background.webp 250w,\n/static/8131e3611fd2b1ab87ec7b1afec2f09c/7379c/redis-pub-sub-background.webp 500w,\n/static/8131e3611fd2b1ab87ec7b1afec2f09c/40e69/redis-pub-sub-background.webp 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[]},"width":1000,"height":500}},"publicURL":"/static/8131e3611fd2b1ab87ec7b1afec2f09c/redis-pub-sub-background.png"}}}}]}},"pageContext":{"slug":"/redis-pub-sub/"}},"staticQueryHashes":[],"slicesMap":{}}